# Available parameters and their default values for the SeaweedFS chart.

global:
  createClusterRole: true
  registry: ""
  repository: ""
  imageName: chrislusf/seaweedfs
  imagePullPolicy: IfNotPresent
  imagePullSecrets: ""
  restartPolicy: Always
  loggingLevel: 1
  monitoring:
    enabled: false
    gatewayHost: null
    gatewayPort: null
  extraEnvironmentVars:
    WEED_CLUSTER_DEFAULT: "sw"
    WEED_CLUSTER_SW_MASTER: "seaweedfs-master.seaweedfs:9333"
    WEED_CLUSTER_SW_FILER: "seaweedfs-filer-client.seaweedfs:8888"

  ## @param global.topologicalReplication
  ##  configures topological placement of replicas created for both the
  ##   master and filer services.
  ##
  ## Note: this relies upon the topology configuration of volume servers.
  ##
  ## Note: replication in different data centeers and/or in different racks
  ##       is only feasible when creating multiple, _separate_ releases of
  ##       this chart that have volume servers configured with different
  ##       topologies, and that have all been configured to serve as one
  ##       cohesive seaweedfs cluster.
  ##
  topologicalReplication:
    enabled: false
    ## @param global.topologicalReplication.countInDifferentDataCenters
    ##
    ## Note: the maximum value is 9
    ##
    ## Note: please read the second note above before setting.
    ##
    countInDifferentDataCenters: 0
    ## @param global.topologicalReplication.countInSameDataCenterAndSameRack
    ##
    ## Note: the maximum value is 9
    ##
    countInSameDataCenterAndSameRack: 0
    ## @param global.topologicalReplication.countInSameDataCenterButDifferentRacks
    ##
    ## Note: the maximum value is 9
    ##
    ## Note: please read the second note above before setting.
    ##
    countInSameDataCenterButDifferentRacks: 0

  ## @param global.storageClass PVC Storage Class for all component
  ##  persistence
  ##
  ## If defined, storageClassName: <storageClass>
  ##
  ## If set to "-", storageClassName: "", which disables dynamic provisioning
  ##
  ## If undefined (the default) or set to null, no storageClassName spec is
  ## set, choosing the default provisioner.
  ##
  storageClass: ""

  ## @param global.s3 Defines configuration for the s3 gateway.
  ##
  ## Note: this configuration is shared between the filer and the
  ##       s3 server components, depending on which is enabled.
  ##
  s3Gateway:
    ## @param global.s3Gateway.allowDeleteBucketNotEmpty
    ##
    allowDeleteBucketNotEmpty: true
    ## @param global.s3Gateway.allowEmptyFolder
    ##
    allowEmptyFolder: true
    ## @param global.s3Gateway.domainName
    ##  The domain name that the s3 gateway will be configured with.
    ##
    domainName: ""

    ## @param global.s3Gateway.auditLog
    auditLog:
      ## @param global.s3Gateway.auditLog.jsonContent [object]
      ##  Defines the contents that will be encoded as json and injected
      ##   into th s3 gateway's audit log configuration file.
      ##
      jsonContents: {}
      
    ## @param global.s3Gateway.auth Defines auth related configuration
    ##  for the s3 gateway.
    ##
    auth:
      ## @param global.s3Gateway.auth.enabled
      ##  specifies whether auth should be enalbed for the s3 gateway.
      ##
      ##  if enabled, a configuration file will be created for the s3
      ##   gateway containing enabled identities. separately, a secret
      ##   will be created containing the supplied credentials.
      ##
      ##  if not enabled, then _any_ credentials supplied to the s3
      ##   gateway will automatically be granted full permissions.
      ##
      enabled: true
      
      ## @param global.s3Gateway.auth.extraIdentitiesSecret
      ##  specifies the name of a secret containing additional s3 gateway
      ##   identities.
      ##
      ## Note: the secret is expected to contain a stringData key of
      ##       `identities.json` that is mapped to a json formatted
      ##       array of valid s3 gateway identity objects.
      ##
      ## e.g.
      ##
      ## ---
      ## apiVersion: v1
      ## kind: Secret
      ## ...
      ## stringData:
      ##   identities.json: '[{"name":"my-identity","actions":["Read"],"credentials":[{"accessKey":"my-access-key","secretKey":"my-secret-key"}]}]'
      ##
      extraIdentitiesSecret: ""

      ## @param global.s3Gateway.auth.identities
      ##  provides auth configuration options for this charts
      ##   "built-in" identities.
      ##
      identities:
        ## @param global.s3Gateway.auth.identities.administrator Auth configuration
        ##  for the `administrator` s3 gateway identity.
        ##
        administrator:
          ## @param global.s3Gateway.auth.identities.administrator.enabled Enables
          ##  the `administrator` s3 gateway identity.
          ##
          enabled: true
          ## @param global.s3Gateway.auth.identities.administrator.credentials
          ##  A list of s3 gateway access credentials that will grant
          ##   the `administrator` identity privileges.
          ##
          ## Note: these do *NOT* need to be access keys granted by AWS;
          ##       they are only used by the seaweedfs s3 gateway alone.
          ##
          ## e.g.
          ## credentials:
          ##  - accessKey: "1234567890ABCDEFG"
          ##    secretKey: "1234567890ABCDEFG"
          ##
          credentials: []
          ## @param global.s3Gateway.auth.identities.administrator.credentialsExistingSecret
          ##  the name of an existing secret containing a list of key pairs
          ##   that will be registered under the built-in `administrator` identity.
          ##
          ## e.g.
          ## ---
          ## apiVersion: v1
          ## kind: Secret
          ## ...
          ## stringData:
          ##   credentials.json: '[{"accessKey":"access-key","secretKey":"secret-key"}]'
          ##
          credentialsExistingSecret: ""
        ## @param global.s3Gateway.auth.identities.anonymous Auth configuration
        ##  for the `anonymous` s3 gateway identity.
        ##
        ## Note: the `anonymous` identity can:
        ##       - read bucket files**
        ##
        ## ** this effectively means that they must have a direct link
        ##    to the bucket file in order to access.
        ##
        anonymous:
          ## @param global.s3Gateway.auth.identities.administrator.enabled
          ##  Enables the `anonymous` s3 gateway identity.
          ##
          enabled: false
        ## @param global.s3Gateway.auth.identities.guest Auth configuration for
        ##   the `guest` s3 gateway identity.
        ##
        ## Note: the `guest` identity can:
        ##       - list all bucket folders and files
        ##       - read all bucket files
        ##
        guest:
          ## @param global.s3Gateway.auth.identities.administrator.enabled
          ##  Enables the `guest` s3 gateway identity.
          ##
          enabled: true
          ## @param global.s3Gateway.auth.identities.administrator.credentials
          ##  A list of s3 gateway access credentials that will grant
          ##   the `guest` identity privileges.
          ##
          ## Note: these do *NOT* need to be access keys granted by AWS;
          ##       they are only used by the seaweedfs s3 gateway alone.
          ##
          ## e.g.
          ## credentials:
          ##  - accessKey: "1234567890ABCDEFG"
          ##    secretKey: "1234567890ABCDEFG"
          ##
          credentials: []
          ## @param global.s3Gateway.auth.identities.guest.credentialsExistingSecret
          ##  the name of an existing secret containing a list of key pairs
          ##   that will be registered under the built-in `guest` identity.
          ##
          ## e.g.
          ## ---
          ## apiVersion: v1
          ## kind: Secret
          ## ...
          ## stringData:
          ##   credentials.json: '[{"accessKey":"access-key","secretKey":"secret-key"}]'
          ##
          credentialsExistingSecret: ""
        ## @param global.s3Gateway.auth.identities.member Auth configuration for
        ##  the `member` s3 gateway identity.
        ##
        ## Note: the `member` identity can:
        ##       - list all bucket folders and files
        ##       - read all bucket files
        ##       - create new bucket files
        ##       - tag bucket files
        ##
        member:
          ## @param global.s3Gateway.auth.identities.administrator.enabled
          ##  Enables the `member` s3 gateway identity.
          ##
          enabled: true
          ## @param global.s3Gateway.auth.identities.administrator.credentials
          ##  A list of s3 gateway access credentials that will grant
          ##   the `member` identity privileges.
          ##
          ## Note: these do *NOT* need to be access keys granted by AWS;
          ##       they are only used by the seaweedfs s3 gateway alone.
          ##
          ## e.g.
          ## credentials:
          ##  - accessKey: "1234567890ABCDEFG"
          ##    secretKey: "1234567890ABCDEFG"
          ##
          credentials: []
          ## @param global.s3Gateway.auth.identities.member.credentialsExistingSecret
          ##  the name of an existing secret containing a list of key pairs
          ##   that will be registered under the built-in `member` identity.
          ##
          ## e.g.
          ## ---
          ## apiVersion: v1
          ## kind: Secret
          ## ...
          ## stringData:
          ##   credentials.json: '[{"accessKey":"access-key","secretKey":"secret-key"}]'
          ##
          credentialsExistingSecret: ""

    ## @param global.s3Gateway.ports
    ##
    ports:
      ##
      ## @param global.s3Gateway.http [int] [required]
      ##  Defines a port that the s3 gateway will receieve https
      ##   traffic on.
      ##
      http: 8333
      ##
      ## @param global.s3Gateway.https [int]
      ##  Defines a port that the s3 gateway will receieve https
      ##   traffic on. If not provided https communications will
      ##   be disabled.
      ##
      ##  Note: Ignored if tls has not been enabled.
      ##        See @param global.tls
      ##
      https: ""

  ## @param global.tls TLS configuration
  ##
  ## Note: TLS will be configured under the following assumptions:
  ##      - cert-manager, istio, and vault have all been installed.
  ##      - vault has been configured to serve as the certificate
  ##        authority for cert-manager.
  ##      - vault has authorized an `internal-ca` kubernetes role that
  ##        can create short-lived certificates.
  ##      - any kubernetes service account can access/assume the
  ##        `internal-ca` kubernete role.
  ##      - istio has been configured/authorized to read/validate
  ##        certificates created by the role.
  ##
  tls:
    ## @param tls.enabled Enable TLS traffic
    ##
    enabled: false
    ## @param tls.enabled Name of an existing tls ecertificate secret
    ##  that will be used instead of creating a certificate.
    ##
    existingSecret: ""
    ## @param tls.enabled Enables istio's `STRICT` mtls mode for peer
    ##   authentication to seaweed services.
    ##
    mutualTLSRequired: false

image:
  registry: ""
  repository: ""

master:
  enabled: true
  repository: null
  imageName: null
  imageTag: null
  imageOverride: null
  restartPolicy: null
  replicas: 1
  ipBind: "0.0.0.0"

  initContainers: ""

  extraVolumes: ""
  extraVolumeMounts: ""

  # Resource requests, limits, etc. for the master cluster placement. This
  # should map directly to the value of the resources field for a PodSpec,
  # formatted as a multi-line string. By default no direct resource request
  # is made.
  resources: null

  # updatePartition is used to control a careful rolling update of SeaweedFS
  # masters.
  updatePartition: 0

  # Affinity Settings
  # Commenting out or setting as empty the affinity variable, will allow
  # deployment to single node services such as Minikube
  affinity: |
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/name: {{ template "seaweedfs.name" . }}
              app.kubernetes.io/instance: {{ .Release.Name }}
              app.kubernetes.io/component: master
          topologyKey: kubernetes.io/hostname

  # Toleration Settings for master pods
  # This should be a multi-line string matching the Toleration array
  # in a PodSpec.
  tolerations: ""

  # nodeSelector labels for master pod assignment, formatted as a muli-line string.
  # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  # Example:
  nodeSelector: |
    kubernetes.io/arch: amd64
  # nodeSelector: |
  #   sw-backend: "true"

  # used to assign priority to master pods
  # ref: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  priorityClassName: ""

  # used to assign a service account.
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  serviceAccountName: ""

  extraEnvironmentVars:
    WEED_MASTER_VOLUME_GROWTH_COPY_1: 7
    WEED_MASTER_VOLUME_GROWTH_COPY_2: 6
    WEED_MASTER_VOLUME_GROWTH_COPY_3: 3
    WEED_MASTER_VOLUME_GROWTH_COPY_OTHER: 1

  # used to configure livenessProbe on master-server containers
  #
  livenessProbe:
    enabled: true
    httpGet:
      path: /cluster/status
      scheme: HTTP
    initialDelaySeconds: 20
    periodSeconds: 30
    successThreshold: 1
    failureThreshold: 4
    timeoutSeconds: 10

  # used to configure readinessProbe on master-server containers
  #
  readinessProbe:
    enabled: true
    httpGet:
      path: /cluster/status
      scheme: HTTP
    initialDelaySeconds: 10
    periodSeconds: 45
    successThreshold: 2
    failureThreshold: 100
    timeoutSeconds: 10

  ## @param master.configuration [object] Configuration options
  ##  for the master server component.
  ##
  configuration:
    ## @param master.configuration.heartbeatInterval [required]
    ##  specifies the standard hearbeat interval amount in milliseconds.
    ##
    ## Note: this value will be randomly multiplied by a score of 1-1.25.
    ##
    heartbeatInterval: 300
    ## @param master.configuration.preallocateDiskSpaceForVolumes
    ##
    preallocateDiskSpaceForVolumes: false
  
    ## @param master.configuration.file configuration specific to the
    ##  `master.toml` configuration file.
    file:
      ## @param master.configuration.file.tomlContents Defines the contents
      ##  that will be injected into the `master.toml` configuration file.
      ##
      ## e.g.
      ## tomlContents: |-
      ##   config_option: "config_value"
      ##
      tomlContents: ""

    ## @param master.configuration.limits
    ##
    limits:
      ## @param master.configuration.limits.garbageCollectionThreshold [required]
      ##  specifides the percentage threshold at which garbage collection
      ##   will perform a vaccuum to reclaim space.
      ##
      garbageCollectionThreshold: 30.0
      ## @param master.configuration.limits.targetableVolumeMaximumSize [required]
      ##  specifies the maximum volume size in MB before a volume will no longer
      ##   have writes directed to it by the master.
      ##
      targetableVolumeMaximumSize: 30000

    ## @param master.configuration.metrics
    ##
    metrics:
      ## @param master.configuration.heartbeatInterval
      ##  specifies the interval in seconds that metrics will be pushed
      ##   to prometheus.
      ##
      prometheusPushInterval: 15
      
    ## @param master.configuration.ports
    ##
    ports:
      ## @param master.configuration.ports.grpc [required]
      ##  Defines a port that the master server will receieve grpc traffic on.
      ##
      grpc: 19333
      ## @param master.configuration.ports.http
      ##  Defines a port that the master server will receieve https traffic on.
      ##
      http: 9333
      ## @param master.configuration.ports.metrics
      ##  Defines a port that the master server will expose metrics on.
      ##
      metrics: 9237

  # Enable ingress for the master seaweedfs component
  ## note that ingress is configured under the following assumptions:
  ##  - all cluster ingress is managed by an istio ingress gateway
  ingress:
    ## @param main.ingress.annotations
    ##
    annotations: {}
    ## @param server.ingress.enabled
    ##
    enabled: false
    ## @param server.ingress.extraHosts An array with additional hostname(s) to be
    ##   covered by the istio virtual service
    ##
    extraHosts: []
    ## @param server.ingress.hostname Default host for the istio virtual service
    ##
    hostname: "seaweedfs-master.cluster.local"

  ## Enable persistence of master data and logs using Persistent Volume Claims
  ## ref: https://kubernetes.io/docs/user-guide/persistent-volumes/
  ##
  persistence:
    data:
      ## @param master.persistence.data.enabled Enable master data persistence using PVC
      ##
      enabled: true
      ## @param master.persistence.indices.accessModes Persistent Volume Access Modes
      ##
      accessModes:
      - ReadWriteOnce
      ## @param controller.persistence.annotations Annotations for the PVC
      ##
      annotations: {}
      ## @param master.persistence.data.existingClaim
      ##  A manually managed Persistent Volume and Claim.
      ##
      ## Note: If defined, PVC must be created manually before Volume will be bound
      ##
      ## Note: The value is evaluated as a template
      ##
      existingClaim: ""
      ## @param controller.persistence.labels Labels for the PVC
      ##
      labels: {}
      ## @param controller.persistence.mountPath Mount path of the master data volume
      ##
      mountPath: /data
      ## @param controller.persistence.selector Selector to match an existing Persistent Volume for master data PVC.
      ## If set, the PVC can't have a PV dynamically provisioned for it
      ##
      ## e.g.
      ## selector:
      ##   matchLabels:
      ##     app: my-app
      ##
      selector: {}
      ## @param controller.persistence.size PVC Storage Request for master data
      ##
      size: 5Gi
      ## @param master.persistence.data.storageClass PVC Storage Class for master data
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ## set, choosing the default provisioner.
      ##
      storageClass: ""

    logs:
      ## @param master.persistence.logs.enabled Enable master logs persistence using PVC
      ##
      enabled: true
      ## @param master.persistence.indices.accessModes Persistent Volume Access Modes
      ##
      accessModes:
      - ReadWriteOnce
      ## @param controller.persistence.annotations Annotations for the PVC
      ##
      annotations: {}
      ## @param master.persistence.logs.existingClaim A manually managed Persistent Volume and Claim
      ## If defined, PVC must be created manually before Volume will be bound
      ## The value is evaluated as a template
      ##
      existingClaim: ""
      ## @param controller.persistence.labels Labels for the PVC
      ##
      labels: {}
      ## @param controller.persistence.mountPath Mount path of the master logs volume
      ##
      mountPath: /logs
      ## @param controller.persistence.selector Selector to match an existing Persistent Volume for master logs PVC.
      ## If set, the PVC can't have a PV dynamically provisioned for it
      ##
      ## e.g.
      ## selector:
      ##   matchLabels:
      ##     app: my-app
      ##
      selector: {}
      ## @param controller.persistence.size PVC Storage Request for master logs
      ##
      size: 1Gi
      ## @param master.persistence.logs.storageClass PVC Storage Class for master logs
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ## set, choosing the default provisioner.
      ##
      storageClass: ""

  ## @param master.podAnnotations Annotations for master pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}

volume:
  enabled: true
  repository: null
  imageName: null
  imageTag: null
  imageOverride: null
  restartPolicy: null
  ipBind: "0.0.0.0"
  replicas: 1

  initContainers: ""

  extraVolumes: ""
  extraVolumeMounts: ""

  # Affinity Settings
  # Commenting out or setting as empty the affinity variable, will allow
  # deployment to single node services such as Minikube
  affinity: |
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/name: {{ template "seaweedfs.name" . }}
              app.kubernetes.io/instance: {{ .Release.Name }}
              app.kubernetes.io/component: volume
          topologyKey: kubernetes.io/hostname

  # Resource requests, limits, etc. for the server cluster placement. This
  # should map directly to the value of the resources field for a PodSpec,
  # formatted as a multi-line string. By default no direct resource request
  # is made.
  resources: null

  # Toleration Settings for server pods
  # This should be a multi-line string matching the Toleration array
  # in a PodSpec.
  tolerations: ""

  # nodeSelector labels for server pod assignment, formatted as a muli-line string.
  # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  # Example:
  nodeSelector: |
   kubernetes.io/arch: amd64
  # nodeSelector: |
  #   sw-volume: "true"

  # used to assign priority to server pods
  # ref: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  priorityClassName: ""

  # used to assign a service account.
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  serviceAccountName: ""

  # used to configure livenessProbe on volume-server containers
  #
  livenessProbe:
    enabled: true
    httpGet:
      path: /status
      scheme: HTTP
    initialDelaySeconds: 20
    periodSeconds: 90
    successThreshold: 1
    failureThreshold: 4
    timeoutSeconds: 30

  # used to configure readinessProbe on volume-server containers
  #
  readinessProbe:
    enabled: true
    httpGet:
      path: /status
      scheme: HTTP
    initialDelaySeconds: 15
    periodSeconds: 15
    successThreshold: 1
    failureThreshold: 100
    timeoutSeconds: 30

  ## @param volume.configuration Configuration for the volume server component.
  ##
  configuration:
    ## @param s3.configuration.allowRequestsToBypassSlowReads
    ##  specifies weather the volume server should continue to service
    ##   requests during slow read operations.
    ##
    ## Note: this will lead to an increase in P99 latency for larger files.
    ##
    allowRequestsToBypassSlowReads: false
    ## @param s3.configuration.autoAdjustImageOrientation
    ##  specifies whether the volume server should automatically adjust
    ##   image orientation upon upload.
    ##
    ## Note: this curretly only works for `jpg` image types.
    ##
    autoAdjustImageOrientation: false
    ## @param s3.configuration.fileAccessBufferSize
    ##  specifies the size in MB that will be used to buffer reads to
    ##   files on the volume server's volumes.
    ##
    ## Note: increasing this size may help to optimize read performance
    ##       but will also increase memory utilization.
    ##
    ## Note: this value should be configured appropriately when
    ##       s3.configuration.allowRequestsToBypassSlowReads is true.
    ##
    fileAccessBufferSize: 4
    ## @param s3.configuration.indexingImplementation [required]
    ##  specifies the implementation for indexing that the volume server
    ##   will use.
    ##
    ## Note: the following indexing implementations are supported, each with
    ##       a different memory~performance tradeoff:
    ##       - memory
    ##       - leveldb
    ##       - leveldbMedium
    ##       - leveldbLarge
    ##
    indexingImplementation: "memory"
    ## @param s3.configuration.nonLocalVolumeReadRequestPolicy [required]
    ##  specifies what the volume server should do with requests made
    ##   to volumes that are not local to the server.
    ##
    ## Note: the following policies are supported:
    ##       - `local`   : this policy will deny requests made to any volumes
    ##                     not managed by the volume server
    ##       - `proxy`   : this policy will result in the volume server proxying
    ##                     requests to the remote node managing the volume.
    ##       - `reidrect`: this policy will result in the volume server
    ##                     redirecting the request to the volume's location.
    ##
    nonLocalVolumeReadRequestPolicy: "proxy"
    ## @param s3.configuration.writePermissionsIPWhitelist
    ##  a list of ip addresses that will be whitelisted as having full
    ##   write permissions on the volume servers volumes.
    ##
    ## Note: an empty list will indicate that no ip will be denied
    ##       write permissions.
    ##
    writePermissionsIPWhitelist: []

    ## @param s3.configuration.limits
    ##
    limits:
      ## @param s3.configuration.limits.backgroundCompactionRate
      ##  the maximum rate in MBs per second that background compaction
      ##   or copying speed will be limited to.
      ##
      backgroundCompactionRate: 50
      ## @param s3.configuration.limits.diskSpaceUtilization [required]
      ##  the maximum amount of disk space utilization (as a percentage)
      ##   that can be used before the volume will go into read-only mode.
      ##
      diskSpaceUtilization: 95.0
      ## @param s3.configuration.limits.fileSize [required]
      ##  the maximum supported file size in MB.
      ##
      ## Note: setting to high of a file size may lead to OOM errors.
      ##
      filseSize: 256
      ## @param s3.configuration.limits.volumeCount [required]
      ##  the maximum amount of volumes allowed.
      ##
      volumeCount: 8

      ## @param s3.configuration.limits.conccurreny
      ##  defines concurrency limitations for network io
      ##
      concurrency:
        ## @param s3.configuration.limits.conccurreny [required]
        ##  specifies the maximum size in MB that concurrent
        ##   downloads may reach
        ##
        downloadSize: 256
        ## @param s3.configuration.limits.conccurreny [required]
        ##  specifies the maximum size in MB that concurrent
        ##   uploads may reach
        ##
        updloadSize: 256

    ## @param s3.configuration.ports
    ##
    ports:
      ## @param s3.configuration.ports.grpc [required]
      ##  Defines a port that the s3 server will receieve grpc traffic on.
      ##
      grpc: 18080
      ## @param s3.configuration.ports.http [required]
      ##  Defines a port that the s3 server will receieve https traffic on.
      ##
      http: 8080
      ## @param s3.configuration.ports.metrics
      ##  Defines a port that the s3 server will expose metrics on.
      ##
      metrics: 9237

    ## @param s3.configuraiton.toplogy
    ##  Defines configuration of the volume server topology, used for
    ##   replication configuration acorss server components.
    ##
    topology:
      ## @param s3.configuration.topology.dataCenterName [required]
      ##  the name of the toplogical data center the volume server
      ##   will be considered assigned to.
      ##
      dataCenterName: "dc1"
      ## @param s3.configuration.topology.rackName [required]
      ##  the name of the toplogical data center rack the volume server
      ##   will be considered assigned to.
      ##
      rackName: "r1"

  ## Enable persistence of volume data, indices, and logs using Persistent Volume Claims
  ## ref: https://kubernetes.io/docs/user-guide/persistent-volumes/
  ##
  persistence:
    data:
      ## @param volume.persistence.data.enabled Enable volume data persistence using PVC
      ##
      enabled: true
      ## @param volume.persistence.indices.accessModes Persistent Volume Access Modes
      ##
      accessModes:
      - ReadWriteOnce
      ## @param controller.persistence.annotations Annotations for the PVC
      ##
      annotations: {}
      ## @param volume.persistence.data.existingClaim A manually managed Persistent Volume and Claim
      ## If defined, PVC must be created manually before Volume will be bound
      ## The value is evaluated as a template
      ##
      existingClaim: ""
      ## @param controller.persistence.labels Labels for the PVC
      ##
      labels: {}
      ## @param controller.persistence.mountPath Mount path of the volume data volume
      ##
      mountPath: /data
      ## @param controller.persistence.selector Selector to match an existing Persistent Volume for volume data PVC.
      ## If set, the PVC can't have a PV dynamically provisioned for it
      ##
      ## e.g.
      ## selector:
      ##   matchLabels:
      ##     app: my-app
      ##
      selector: {}
      ## @param controller.persistence.size PVC Storage Request for volume data
      ##
      size: 5Gi
      ## @param volume.persistence.data.storageClass PVC Storage Class for volume data
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ## set, choosing the default provisioner.
      ##
      storageClass: ""

    indices:
      ## @param volume.persistence.indices.enabled Enable volume indices persistence using PVC
      ##
      enabled: true
      ## @param volume.persistence.indices.accessModes Persistent Volume Access Modes
      ##
      accessModes:
      - ReadWriteOnce
      ## @param controller.persistence.annotations Annotations for the PVC
      ##
      annotations: {}
      ## @param volume.persistence.indices.existingClaim A manually managed Persistent Volume and Claim
      ## If defined, PVC must be created manually before Volume will be bound
      ## The value is evaluated as a template
      ##
      existingClaim: ""
      ## @param controller.persistence.labels Labels for the PVC
      ##
      labels: {}
      ## @param controller.persistence.mountPath Mount path of the volume indices volume
      ##
      mountPath: /indices
      ## @param controller.persistence.selector Selector to match an existing Persistent Volume for volume indices PVC.
      ## If set, the PVC can't have a PV dynamically provisioned for it
      ##
      ## e.g.
      ## selector:
      ##   matchLabels:
      ##     app: my-app
      ##
      selector: {}
      ## @param controller.persistence.size PVC Storage Request for volume indices
      ##
      size: 5Gi
      ## @param volume.persistence.indices.storageClass PVC Storage Class for volume indices
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ## set, choosing the default provisioner.
      ##
      storageClass: ""

    logs:
      ## @param volume.persistence.logs.enabled Enable volume logs persistence using PVC
      ##
      enabled: true
      ## @param volume.persistence.indices.accessModes Persistent Volume Access Modes
      ##
      accessModes:
      - ReadWriteOnce
      ## @param controller.persistence.annotations Annotations for the PVC
      ##
      annotations: {}
      ## @param volume.persistence.logs.existingClaim A manually managed Persistent Volume and Claim
      ## If defined, PVC must be created manually before Volume will be bound
      ## The value is evaluated as a template
      ##
      existingClaim: ""
      ## @param controller.persistence.labels Labels for the PVC
      ##
      labels: {}
      ## @param controller.persistence.mountPath Mount path of the volume logs volume
      ##
      mountPath: /logs
      ## @param controller.persistence.selector Selector to match an existing Persistent Volume for volume logs PVC.
      ## If set, the PVC can't have a PV dynamically provisioned for it
      ##
      ## e.g.
      ## selector:
      ##   matchLabels:
      ##     app: my-app
      ##
      selector: {}
      ## @param controller.persistence.size PVC Storage Request for volume logs
      ##
      size: 1Gi
      ## @param volume.persistence.logs.storageClass PVC Storage Class for volume logs
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ## set, choosing the default provisioner.
      ##
      storageClass: ""

  ## @param master.podAnnotations Annotations for volume pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}

filer:
  enabled: true
  repository: null
  imageName: null
  imageTag: null
  imageOverride: null
  restartPolicy: null
  replicas: 1
  initContainers: ""

  extraVolumes: ""

  extraVolumeMounts: ""

  # Affinity Settings
  # Commenting out or setting as empty the affinity variable, will allow
  # deployment to single node services such as Minikube
  affinity: |
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/name: {{ template "seaweedfs.name" . }}
              app.kubernetes.io/instance: {{ .Release.Name }}
              app.kubernetes.io/component: filer
          topologyKey: kubernetes.io/hostname

  # updatePartition is used to control a careful rolling update of SeaweedFS
  # masters.
  updatePartition: 0

  # Resource requests, limits, etc. for the server cluster placement. This
  # should map directly to the value of the resources field for a PodSpec,
  # formatted as a multi-line string. By default no direct resource request
  # is made.
  resources: null

  # Toleration Settings for server pods
  # This should be a multi-line string matching the Toleration array
  # in a PodSpec.
  tolerations: ""

  # nodeSelector labels for server pod assignment, formatted as a muli-line string.
  # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  # Example:
  nodeSelector: |
    kubernetes.io/arch: amd64
  # nodeSelector: |
  #   sw-backend: "true"

  # used to assign priority to server pods
  # ref: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  priorityClassName: ""

  # used to assign a service account.
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  serviceAccountName: ""

  # extraEnvVars is a list of extra enviroment variables to set with the stateful set.
  extraEnvironmentVars:
    # directories under this folder will be automatically creating a separate bucket
    WEED_FILER_BUCKETS_FOLDER: "/buckets"

  # used to configure livenessProbe on filer containers
  #
  livenessProbe:
    enabled: true
    httpGet:
      path: /
      scheme: HTTP
    initialDelaySeconds: 20
    periodSeconds: 30
    successThreshold: 1
    failureThreshold: 5
    timeoutSeconds: 10

  # used to configure readinessProbe on filer containers
  #
  readinessProbe:
    enabled: true
    httpGet:
      path: /
      scheme: HTTP
    initialDelaySeconds: 10
    periodSeconds: 15
    successThreshold: 1
    failureThreshold: 100
    timeoutSeconds: 10

  # secret env variables
  secretExtraEnvironmentVars: []
      # WEED_POSTGRES_USERNAME:
      #   secretKeyRef:
      #     name: postgres-credentials
      #     key: username
      # WEED_POSTGRES_PASSWORD:
      #   secretKeyRef:
      #     name: postgres-credentials
      #     key: password

  ## @param filer.auth [object] Defines auth related options for the filer server.
  ##
  auth:
    ## @param filer.auth.store
    ##
    ## Note: store auth is ignored if the filer's store is not configured.
    ##       see @param filer.configuration.store
    ##
    store:
      ## @param filer.auth.store.credentials
      ##  if defined, a secret will be created containing the credentials for
      ##   the store and injected into the filer.toml configuration file for
      ##   the store's configuration section.
      ##
      ## Note: credentials will be ignored if an existing secret is provided.
      ##       see @param filer.auth.store.existingCredentialsSecret below
      ##
      credentials:
        username: ""
        password: ""

      ## @param filer.auth.store.credentialsExistingSecret
      ##  specifies the name of an existing secret that will be used to source
      ##   the `username` and `password` for the filer's store.
      ##
      credentialsExistingSecret: ""

  ## @param filer.configuration Configuration for the filer server component.
  ##
  configuration:
    ## @param filer.configuration.disableDirectoryListing
    ##
    disableDirectoryListing: false
    ## @param filer.configuration.encryptVolumeData
    ##
    encryptVolumeData: false
    ## @param filer.configuration.groupName [required]
    ##  the name of the filer group.
    ##
    ## Note: all filers within the same group share their metadata.
    ##
    groupName: "default"
    ## @param filer.configuration.redirectReadsToVolumeServer
    ##  Specifies whether GET requestss to the filer should be (proxied)
    ##   redirected to the volume server
    ##
    redirectReadsToVolumeServer: false

    ## @param filer.configuration.limits
    ##
    limits:
      ## @param filer.configuration.limits.directoryListingSize [required]
      ##  the maximum number of items that will be listed for a direcotry.
      ##
      directoryListingSize: 100000
      ## @param filer.configuration.limits.fileChunkSize [required]
      ##  the maximum size (in MB) that a file may be before it is chunked.
      ##
      fileChunkSize: 32

    ## @param filer.configuration.options Defines configuration options for the filer
    ##
    options:
      ## @param filer.configuration.options.tomlContents [string] Contains the toml-formatted
      ##  contents that will be injected into the `filer.toml` configuration file's `filer.options`
      ##  table.
      ## e.g.
      ## tomlContents: |-
      ##   recursive_delete = false
      ##
      tomlContents: ""

    ## @param filer.configuration.ports
    ##
    ports:
      ## @param filer.configuration.ports.grpc [required]
      ##  Defines a port that the filer will receieve grpc traffic on.
      ##
      grpc: 18888
      ## @param filer.configuration.ports.http
      ##  Defines a port that the filer will receieve https traffic on.
      ##
      ##  Note: this may be set to `false` or an empty string to disable
      ##        http traffic.
      ##
      http: 8888
      ## @param filer.configuration.ports.metrics
      ##  Defines a port that the filer will expose metrics on.
      ##
      metrics: 9237

    ## @ param filer.configuration.store Defines the configuration of the filer's store.
    ##
    store:
      ## @param filer.configuration.store.sectionNameForConfigurationFileStoreSection
      ##  specifies the name of the supported storage mechanism that the filer will be
      ##   confiured for.
      ##
      ## Note: as the property name implies, this value should contain the configuration
      ##       section headerer name featured in the filer.toml file.
      ##
      ## e.g.
      ## sectionNameForConfigurationFileStoreSection: "redis_cluster3"
      ##
      sectionNameForConfigurationFileStoreSection: ""
      ## @param filer.configuration.store.tomlContentsForConfigurationFileStoreSection
      ##  the toml formatted contents that will be injected into configuration section
      ##   for the store in the `filer.toml` configuration file.
      ##
      ## e.g.
      ## tomlContentsForConfigurationFileStoreSection: |-
      ##   enabled = true
      ##   hostname = "database.seawedfs.svc.cluster.local"
      ##   ...
      ##
      tomlContentsForConfigurationFileStoreSection: ""

  # Enable ingress for the filer seaweedfs component
  ## note that ingress is configured under the following assumptions:
  ##  - all cluster ingress is managed by an istio ingress gateway
  ingress:
    ## @param main.ingress.annotations
    ##
    annotations: {}
    ## @param server.ingress.enabled
    ##
    enabled: false
    ## @param server.ingress.extraHosts An array with additional hostname(s) to be covered
    ##        by the istio virtual service
    ##
    extraHosts: []
    ## @param server.ingress.hostname Default host for the istio virtual service
    ##
    hostname: "seaweedfs-filer.cluster.local"

  ## Enable persistence of filer data and logs using Persistent Volume Claims
  ## ref: https://kubernetes.io/docs/user-guide/persistent-volumes/
  ##
  persistence:
    data:
      ## @param filer.persistence.data.enabled Enable filer data persistence using PVC
      ##
      ## Note: data persistence is Ignored if @param filer.configuration.store.enabled
      ##       is set to true.
      ##
      enabled: true
      ## @param filer.persistence.indices.accessModes Persistent Volume Access Modes
      ##
      accessModes:
      - ReadWriteOnce
      ## @param controller.persistence.annotations Annotations for the PVC
      ##
      annotations: {}
      ## @param filer.persistence.data.existingClaim A manually managed Persistent Volume and Claim
      ## If defined, PVC must be created manually before Volume will be bound
      ## The value is evaluated as a template
      ##
      existingClaim: ""
      ## @param controller.persistence.labels Labels for the PVC
      ##
      labels: {}
      ## @param controller.persistence.mountPath Mount path of the filer data volume
      ##
      mountPath: /data
      ## @param controller.persistence.selector Selector to match an existing Persistent Volume for filer data PVC.
      ## If set, the PVC can't have a PV dynamically provisioned for it
      ##
      ## e.g.
      ## selector:
      ##   matchLabels:
      ##     app: my-app
      ##
      selector: {}
      ## @param controller.persistence.size PVC Storage Request for filer data
      ##
      size: 5Gi
      ## @param filer.persistence.data.storageClass PVC Storage Class for filer data
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ## set, choosing the default provisioner.
      ##
      storageClass: ""

    logs:
      ## @param filer.persistence.logs.enabled Enable filer logs persistence using PVC
      ##
      enabled: true
      ## @param filer.persistence.indices.accessModes Persistent Volume Access Modes
      ##
      accessModes:
      - ReadWriteOnce
      ## @param controller.persistence.annotations Annotations for the PVC
      ##
      annotations: {}
      ## @param filer.persistence.logs.existingClaim A manually managed Persistent Volume and Claim
      ## If defined, PVC must be created manually before Volume will be bound
      ## The value is evaluated as a template
      ##
      existingClaim: ""
      ## @param controller.persistence.labels Labels for the PVC
      ##
      labels: {}
      ## @param controller.persistence.mountPath Mount path of the filer logs volume
      ##
      mountPath: /logs
      ## @param controller.persistence.selector Selector to match an existing Persistent Volume for filer logs PVC.
      ## If set, the PVC can't have a PV dynamically provisioned for it
      ##
      ## e.g.
      ## selector:
      ##   matchLabels:
      ##     app: my-app
      ##
      selector: {}
      ## @param controller.persistence.size PVC Storage Request for filer logs
      ##
      size: 1Gi
      ## @param filer.persistence.logs.storageClass PVC Storage Class for filer logs
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ## set, choosing the default provisioner.
      ##
      storageClass: ""

  ## @param master.podAnnotations Annotations for filer pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}

  ## @param filer.s3 [object] Defines configuration options for the filer server's
  ##  s3 capabilities.
  ##
  s3Gateway:
    ## @param filer.s3.enabled Specifies whether the filer should enable its s3
    ##  gateway capabilities.
    ##
    ## Note: this option is ignored if the `s3` server component is enabled.
    ##
    enabled: true

s3:
  enabled: false
  repository: null
  imageName: null
  imageTag: null
  restartPolicy: null
  replicas: 1
  bindAddress: 0.0.0.0

  initContainers: ""

  extraVolumes: ""

  extraVolumeMounts: ""

  # Resource requests, limits, etc. for the server cluster placement. This
  # should map directly to the value of the resources field for a PodSpec,
  # formatted as a multi-line string. By default no direct resource request
  # is made.
  resources: {}

  # Toleration Settings for server pods
  # This should be a multi-line string matching the Toleration array
  # in a PodSpec.
  tolerations: ""

  # nodeSelector labels for server pod assignment, formatted as a muli-line string.
  # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  # Example:
  nodeSelector: |
    kubernetes.io/arch: amd64
  # nodeSelector: |
  #   sw-backend: "true"

  # used to assign priority to server pods
  # ref: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  priorityClassName: ""

  # used to assign a service account.
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  serviceAccountName: ""

  # used to configure livenessProbe on s3 containers
  #
  livenessProbe:
    enabled: true
    httpGet:
      path: /status
      scheme: HTTP
    initialDelaySeconds: 20
    periodSeconds: 60
    successThreshold: 1
    failureThreshold: 20
    timeoutSeconds: 10

  # used to configure readinessProbe on s3 containers
  #
  readinessProbe:
    enabled: true
    httpGet:
      path: /status
      scheme: HTTP
    initialDelaySeconds: 15
    periodSeconds: 15
    successThreshold: 1
    failureThreshold: 100
    timeoutSeconds: 10

  ## @param s3.configuration Configuration for the s3 server component.
  ##
  configuration:
    ## @param s3.configuration.ports
    ##
    ports:
      ## @param s3.configuration.ports.metrics
      ##  Defines a port that the s3 server will expose metrics on.
      ##
      metrics: 9237

  ## @param master.podAnnotations Annotations for s3 pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}

certificates:
  ipAddresses: []
